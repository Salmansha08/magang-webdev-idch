/*!
 * perfect-scrollbar v1.1.0
 * (c) 2017 Hyunje Jun
 * @license MIT
 */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define(e) : t.PerfectScrollbar = e() }(this, function () { 'use strict'; function t (t) { return getComputedStyle(t) } function e (t, e) { for (const i in e) { let n = e[i]; typeof n === 'number' && (n += 'px'), t.style[i] = n } return t } function i (t) { const e = document.createElement('div'); return e.className = t, e } function n (t, e) { if (!v) throw new Error('No element matching method supported'); return v.call(t, e) } function r (t) { t.remove ? t.remove() : t.parentNode && t.parentNode.removeChild(t) } function l (t, e) { return Array.prototype.filter.call(t.children, function (t) { return n(t, e) }) } function o (t, e) { const i = t.element.classList; const n = m.state.scrolling(e); i.contains(n) ? clearTimeout(w[e]) : i.add(n) } function s (t, e) { w[e] = setTimeout(function () { return t.element.classList.remove(m.state.scrolling(e)) }, t.settings.scrollingThreshold) } function a (t, e) { o(t, e), s(t, e) } function c (t) { if (typeof window.CustomEvent === 'function') return new CustomEvent(t); const e = document.createEvent('CustomEvent'); return e.initCustomEvent(t, !1, !1, void 0), e } function h (t, e, i, n) { const r = i[0]; const l = i[1]; const o = i[2]; const s = i[3]; const h = i[4]; const u = i[5]; const d = t.element; let p = !1; t.reach[s] = null, e <= 0 && (e = 0, t.reach[s] = 'start'), e >= t[r] - t[l] && ((e = t[r] - t[l]) - d[o] <= 2 && (p = !0), t.reach[s] = 'end'); const f = d[o] - e; f && (d.dispatchEvent(c('ps-scroll-' + s)), f > 0 ? d.dispatchEvent(c('ps-scroll-' + h)) : d.dispatchEvent(c('ps-scroll-' + u)), p || (d[o] = e), t.reach[s] && d.dispatchEvent(c('ps-' + s + '-reach-' + t.reach[s])), n && a(t, s)) } function u (t) { return parseInt(t, 10) || 0 } function d (t) { return n(t, 'input,[contenteditable]') || n(t, 'select,[contenteditable]') || n(t, 'textarea,[contenteditable]') || n(t, 'button,[contenteditable]') } function p (e) { const i = t(e); return u(i.width) + u(i.paddingLeft) + u(i.paddingRight) + u(i.borderLeftWidth) + u(i.borderRightWidth) } function f (t, e) { return t.settings.minScrollbarLength && (e = Math.max(e, t.settings.minScrollbarLength)), t.settings.maxScrollbarLength && (e = Math.min(e, t.settings.maxScrollbarLength)), e } function b (t, i) { const n = { width: i.railXWidth }; i.isRtl ? n.left = i.negativeScrollAdjustment + t.scrollLeft + i.containerWidth - i.contentWidth : n.left = t.scrollLeft, i.isScrollbarXUsingBottom ? n.bottom = i.scrollbarXBottom - t.scrollTop : n.top = i.scrollbarXTop + t.scrollTop, e(i.scrollbarXRail, n); const r = { top: t.scrollTop, height: i.railYHeight }; i.isScrollbarYUsingRight ? i.isRtl ? r.right = i.contentWidth - (i.negativeScrollAdjustment + t.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth : r.right = i.scrollbarYRight - t.scrollLeft : i.isRtl ? r.left = i.negativeScrollAdjustment + t.scrollLeft + 2 * i.containerWidth - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth : r.left = i.scrollbarYLeft + t.scrollLeft, e(i.scrollbarYRail, r), e(i.scrollbarX, { left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth }), e(i.scrollbarY, { top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth }) } function g (t, e) { function i (e) { y(t, p, g + m * (e[a] - v), !1), o(t, f), L(t), e.stopPropagation(), e.preventDefault() } function n () { s(t, f), t.event.unbind(t.ownerDocument, 'mousemove', i) } const r = e[0]; const l = e[1]; var a = e[2]; const c = e[3]; const h = e[4]; const u = e[5]; const d = e[6]; var p = e[7]; var f = e[8]; const b = t.element; var g = null; var v = null; var m = null; t.event.bind(t[h], 'mousedown', function (e) { g = b[d], v = e[a], m = (t[l] - t[r]) / (t[c] - t[u]), t.event.bind(t.ownerDocument, 'mousemove', i), t.event.once(t.ownerDocument, 'mouseup', n), e.stopPropagation(), e.preventDefault() }) } var v = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.msMatchesSelector; var m = { main: 'ps', element: { thumb: function (t) { return 'ps__thumb-' + t }, rail: function (t) { return 'ps__rail-' + t }, consuming: 'ps__child--consume' }, state: { focus: 'ps--focus', active: function (t) { return 'ps--active-' + t }, scrolling: function (t) { return 'ps--scrolling-' + t } } }; var w = { x: null, y: null }; const Y = function (t) { this.element = t, this.handlers = {} }; const X = { isEmpty: { configurable: !0 } }; Y.prototype.bind = function (t, e) { void 0 === this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1) }, Y.prototype.unbind = function (t, e) { const i = this; this.handlers[t] = this.handlers[t].filter(function (n) { return !(!e || n === e) || (i.element.removeEventListener(t, n, !1), !1) }) }, Y.prototype.unbindAll = function () { const t = this; for (const e in t.handlers)t.unbind(e) }, X.isEmpty.get = function () { const t = this; return Object.keys(this.handlers).every(function (e) { return t.handlers[e].length === 0 }) }, Object.defineProperties(Y.prototype, X); const W = function () { this.eventElements = [] }; W.prototype.eventElement = function (t) { let e = this.eventElements.filter(function (e) { return e.element === t })[0]; return e || (e = new Y(t), this.eventElements.push(e)), e }, W.prototype.bind = function (t, e, i) { this.eventElement(t).bind(e, i) }, W.prototype.unbind = function (t, e, i) { const n = this.eventElement(t); n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1) }, W.prototype.unbindAll = function () { this.eventElements.forEach(function (t) { return t.unbindAll() }), this.eventElements = [] }, W.prototype.once = function (t, e, i) { const n = this.eventElement(t); const r = function (t) { n.unbind(e, r), i(t) }; n.bind(e, r) }; var y = function (t, e, i, n) { void 0 === n && (n = !0); let r; if (e === 'top')r = ['contentHeight', 'containerHeight', 'scrollTop', 'y', 'up', 'down']; else { if (e !== 'left') throw new Error('A proper axis should be provided'); r = ['contentWidth', 'containerWidth', 'scrollLeft', 'x', 'left', 'right'] }h(t, i, r, n) }; const R = { isWebKit: document && 'WebkitAppearance' in document.documentElement.style, supportsTouch: window && ('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch), supportsIePointer: navigator && navigator.msMaxTouchPoints }; var L = function (t) { const e = t.element; t.containerWidth = e.clientWidth, t.containerHeight = e.clientHeight, t.contentWidth = e.scrollWidth, t.contentHeight = e.scrollHeight, e.contains(t.scrollbarXRail) || (l(e, m.element.rail('x')).forEach(function (t) { return r(t) }), e.appendChild(t.scrollbarXRail)), e.contains(t.scrollbarYRail) || (l(e, m.element.rail('y')).forEach(function (t) { return r(t) }), e.appendChild(t.scrollbarYRail)), !t.settings.suppressScrollX && t.containerWidth + t.settings.scrollXMarginOffset < t.contentWidth ? (t.scrollbarXActive = !0, t.railXWidth = t.containerWidth - t.railXMarginWidth, t.railXRatio = t.containerWidth / t.railXWidth, t.scrollbarXWidth = f(t, u(t.railXWidth * t.containerWidth / t.contentWidth)), t.scrollbarXLeft = u((t.negativeScrollAdjustment + e.scrollLeft) * (t.railXWidth - t.scrollbarXWidth) / (t.contentWidth - t.containerWidth))) : t.scrollbarXActive = !1, !t.settings.suppressScrollY && t.containerHeight + t.settings.scrollYMarginOffset < t.contentHeight ? (t.scrollbarYActive = !0, t.railYHeight = t.containerHeight - t.railYMarginHeight, t.railYRatio = t.containerHeight / t.railYHeight, t.scrollbarYHeight = f(t, u(t.railYHeight * t.containerHeight / t.contentHeight)), t.scrollbarYTop = u(e.scrollTop * (t.railYHeight - t.scrollbarYHeight) / (t.contentHeight - t.containerHeight))) : t.scrollbarYActive = !1, t.scrollbarXLeft >= t.railXWidth - t.scrollbarXWidth && (t.scrollbarXLeft = t.railXWidth - t.scrollbarXWidth), t.scrollbarYTop >= t.railYHeight - t.scrollbarYHeight && (t.scrollbarYTop = t.railYHeight - t.scrollbarYHeight), b(e, t), t.scrollbarXActive ? e.classList.add(m.state.active('x')) : (e.classList.remove(m.state.active('x')), t.scrollbarXWidth = 0, t.scrollbarXLeft = 0, y(t, 'left', 0)), t.scrollbarYActive ? e.classList.add(m.state.active('y')) : (e.classList.remove(m.state.active('y')), t.scrollbarYHeight = 0, t.scrollbarYTop = 0, y(t, 'top', 0)) }; const H = { 'click-rail': function (t) { const e = t.element; t.event.bind(t.scrollbarY, 'mousedown', function (t) { return t.stopPropagation() }), t.event.bind(t.scrollbarYRail, 'mousedown', function (i) { const n = i.pageY - window.pageYOffset - t.scrollbarYRail.getBoundingClientRect().top > t.scrollbarYTop ? 1 : -1; y(t, 'top', e.scrollTop + n * t.containerHeight), L(t), i.stopPropagation() }), t.event.bind(t.scrollbarX, 'mousedown', function (t) { return t.stopPropagation() }), t.event.bind(t.scrollbarXRail, 'mousedown', function (i) { const n = i.pageX - window.pageXOffset - t.scrollbarXRail.getBoundingClientRect().left > t.scrollbarXLeft ? 1 : -1; y(t, 'left', e.scrollLeft + n * t.containerWidth), L(t), i.stopPropagation() }) }, 'drag-thumb': function (t) { g(t, ['containerWidth', 'contentWidth', 'pageX', 'railXWidth', 'scrollbarX', 'scrollbarXWidth', 'scrollLeft', 'left', 'x']), g(t, ['containerHeight', 'contentHeight', 'pageY', 'railYHeight', 'scrollbarY', 'scrollbarYHeight', 'scrollTop', 'top', 'y']) }, keyboard: function (t) { function e (e, n) { const r = i.scrollTop; if (e === 0) { if (!t.scrollbarYActive) return !1; if (r === 0 && n > 0 || r >= t.contentHeight - t.containerHeight && n < 0) return !t.settings.wheelPropagation } const l = i.scrollLeft; if (n === 0) { if (!t.scrollbarXActive) return !1; if (l === 0 && e < 0 || l >= t.contentWidth - t.containerWidth && e > 0) return !t.settings.wheelPropagation } return !0 } var i = t.element; const r = function () { return n(i, ':hover') }; const l = function () { return n(t.scrollbarX, ':focus') || n(t.scrollbarY, ':focus') }; t.event.bind(t.ownerDocument, 'keydown', function (n) { if (!(n.isDefaultPrevented && n.isDefaultPrevented() || n.defaultPrevented) && (r() || l())) { let o = document.activeElement ? document.activeElement : t.ownerDocument.activeElement; if (o) { if (o.tagName === 'IFRAME')o = o.contentDocument.activeElement; else for (;o.shadowRoot;)o = o.shadowRoot.activeElement; if (d(o)) return } let s = 0; let a = 0; switch (n.which) { case 37:s = n.metaKey ? -t.contentWidth : n.altKey ? -t.containerWidth : -30; break; case 38:a = n.metaKey ? t.contentHeight : n.altKey ? t.containerHeight : 30; break; case 39:s = n.metaKey ? t.contentWidth : n.altKey ? t.containerWidth : 30; break; case 40:a = n.metaKey ? -t.contentHeight : n.altKey ? -t.containerHeight : -30; break; case 32:a = n.shiftKey ? t.containerHeight : -t.containerHeight; break; case 33:a = t.containerHeight; break; case 34:a = -t.containerHeight; break; case 36:a = t.contentHeight; break; case 35:a = -t.contentHeight; break; default:return }t.settings.suppressScrollX && s !== 0 || t.settings.suppressScrollY && a !== 0 || (y(t, 'top', i.scrollTop - a), y(t, 'left', i.scrollLeft + s), L(t), e(s, a) && n.preventDefault()) } }) }, wheel: function (e) { function i (t, i) { const n = o.scrollTop; if (t === 0) { if (!e.scrollbarYActive) return !1; if (n === 0 && i > 0 || n >= e.contentHeight - e.containerHeight && i < 0) return !e.settings.wheelPropagation } const r = o.scrollLeft; if (i === 0) { if (!e.scrollbarXActive) return !1; if (r === 0 && t < 0 || r >= e.contentWidth - e.containerWidth && t > 0) return !e.settings.wheelPropagation } return !0 } function n (t) { let e = t.deltaX; let i = -1 * t.deltaY; return void 0 !== e && void 0 !== i || (e = -1 * t.wheelDeltaX / 6, i = t.wheelDeltaY / 6), t.deltaMode && t.deltaMode === 1 && (e *= 10, i *= 10), e !== e && i !== i && (e = 0, i = t.wheelDelta), t.shiftKey ? [-i, -e] : [e, i] } function r (e, i, n) { if (!R.isWebKit && o.querySelector('select:focus')) return !0; if (!o.contains(e)) return !1; for (let r = e; r && r !== o;) { if (r.classList.contains(m.element.consuming)) return !0; const l = t(r); if ([l.overflow, l.overflowX, l.overflowY].join('').match(/(scroll|auto)/)) { const s = r.scrollHeight - r.clientHeight; if (s > 0 && !(r.scrollTop === 0 && n > 0 || r.scrollTop === s && n < 0)) return !0; const a = r.scrollLeft - r.clientWidth; if (a > 0 && !(r.scrollLeft === 0 && i < 0 || r.scrollLeft === a && i > 0)) return !0 }r = r.parentNode } return !1 } function l (t) { const l = n(t); const s = l[0]; const a = l[1]; if (!r(t.target, s, a)) { let c = !1; e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (a ? y(e, 'top', o.scrollTop - a * e.settings.wheelSpeed) : y(e, 'top', o.scrollTop + s * e.settings.wheelSpeed), c = !0) : e.scrollbarXActive && !e.scrollbarYActive && (s ? y(e, 'left', o.scrollLeft + s * e.settings.wheelSpeed) : y(e, 'left', o.scrollLeft - a * e.settings.wheelSpeed), c = !0) : (y(e, 'top', o.scrollTop - a * e.settings.wheelSpeed), y(e, 'left', o.scrollLeft + s * e.settings.wheelSpeed)), L(e), (c = c || i(s, a)) && (t.stopPropagation(), t.preventDefault()) } } var o = e.element; void 0 !== window.onwheel ? e.event.bind(o, 'wheel', l) : void 0 !== window.onmousewheel && e.event.bind(o, 'mousewheel', l) }, touch: function (t) { function e (e, i) { const n = h.scrollTop; const r = h.scrollLeft; const l = Math.abs(e); const o = Math.abs(i); if (o > l) { if (i < 0 && n === t.contentHeight - t.containerHeight || i > 0 && n === 0) return { stop: !t.settings.swipePropagation, prevent: window.scrollY === 0 } } else if (l > o && (e < 0 && r === t.contentWidth - t.containerWidth || e > 0 && r === 0)) return { stop: !t.settings.swipePropagation, prevent: !0 }; return { stop: !0, prevent: !0 } } function i (e, i) { y(t, 'top', h.scrollTop - i), y(t, 'left', h.scrollLeft - e), L(t) } function n () { b = !0 } function r () { b = !1 } function l (t) { return t.targetTouches ? t.targetTouches[0] : t } function o (t) { return !(t.pointerType && t.pointerType === 'pen' && t.buttons === 0 || (!t.targetTouches || t.targetTouches.length !== 1) && (!t.pointerType || t.pointerType === 'mouse' || t.pointerType === t.MSPOINTER_TYPE_MOUSE)) } function s (t) { if (o(t)) { g = !0; const e = l(t); u.pageX = e.pageX, u.pageY = e.pageY, d = (new Date()).getTime(), f !== null && clearInterval(f), t.stopPropagation() } } function a (n) { if (!g && t.settings.swipePropagation && s(n), !b && g && o(n)) { const r = l(n); const a = { pageX: r.pageX, pageY: r.pageY }; const c = a.pageX - u.pageX; const h = a.pageY - u.pageY; i(c, h), u = a; const f = (new Date()).getTime(); const v = f - d; v > 0 && (p.x = c / v, p.y = h / v, d = f); const m = e(c, h); const w = m.stop; const Y = m.prevent; w && n.stopPropagation(), Y && n.preventDefault() } } function c () { !b && g && (g = !1, t.settings.swipeEasing && (clearInterval(f), f = setInterval(function () { t.isInitialized ? clearInterval(f) : p.x || p.y ? Math.abs(p.x) < 0.01 && Math.abs(p.y) < 0.01 ? clearInterval(f) : (i(30 * p.x, 30 * p.y), p.x *= 0.8, p.y *= 0.8) : clearInterval(f) }, 10))) } if (R.supportsTouch || R.supportsIePointer) { var h = t.element; var u = {}; var d = 0; var p = {}; var f = null; var b = !1; var g = !1; R.supportsTouch ? (t.event.bind(window, 'touchstart', n), t.event.bind(window, 'touchend', r), t.event.bind(h, 'touchstart', s), t.event.bind(h, 'touchmove', a), t.event.bind(h, 'touchend', c)) : R.supportsIePointer && (window.PointerEvent ? (t.event.bind(window, 'pointerdown', n), t.event.bind(window, 'pointerup', r), t.event.bind(h, 'pointerdown', s), t.event.bind(h, 'pointermove', a), t.event.bind(h, 'pointerup', c)) : window.MSPointerEvent && (t.event.bind(window, 'MSPointerDown', n), t.event.bind(window, 'MSPointerUp', r), t.event.bind(h, 'MSPointerDown', s), t.event.bind(h, 'MSPointerMove', a), t.event.bind(h, 'MSPointerUp', c))) } } }; const T = function (n, r) { const l = this; if (void 0 === r && (r = {}), typeof n === 'string' && (n = document.querySelector(n)), !n || !n.nodeName) throw new Error('no element is specified to initialize PerfectScrollbar'); this.element = n, n.classList.add(m.main), this.settings = { handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'], maxScrollbarLength: null, minScrollbarLength: null, scrollingThreshold: 1e3, scrollXMarginOffset: 0, scrollYMarginOffset: 0, suppressScrollX: !1, suppressScrollY: !1, swipePropagation: !0, swipeEasing: !0, useBothWheelAxes: !1, wheelPropagation: !1, wheelSpeed: 1 }; for (const o in r)l.settings[o] = r[o]; this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null; const s = function () { return n.classList.add(m.state.focus) }; const a = function () { return n.classList.remove(m.state.focus) }; this.isRtl = t(n).direction === 'rtl', this.isNegativeScroll = (function () { const t = n.scrollLeft; let e = null; return n.scrollLeft = -1, e = n.scrollLeft < 0, n.scrollLeft = t, e }()), this.negativeScrollAdjustment = this.isNegativeScroll ? n.scrollWidth - n.clientWidth : 0, this.event = new W(), this.ownerDocument = n.ownerDocument || document, this.scrollbarXRail = i(m.element.rail('x')), n.appendChild(this.scrollbarXRail), this.scrollbarX = i(m.element.thumb('x')), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute('tabindex', 0), this.event.bind(this.scrollbarX, 'focus', s), this.event.bind(this.scrollbarX, 'blur', a), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null; const c = t(this.scrollbarXRail); this.scrollbarXBottom = parseInt(c.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = u(c.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = u(c.borderLeftWidth) + u(c.borderRightWidth), e(this.scrollbarXRail, { display: 'block' }), this.railXMarginWidth = u(c.marginLeft) + u(c.marginRight), e(this.scrollbarXRail, { display: '' }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = i(m.element.rail('y')), n.appendChild(this.scrollbarYRail), this.scrollbarY = i(m.element.thumb('y')), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute('tabindex', 0), this.event.bind(this.scrollbarY, 'focus', s), this.event.bind(this.scrollbarY, 'blur', a), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null; const h = t(this.scrollbarYRail); this.scrollbarYRight = parseInt(h.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = u(h.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? p(this.scrollbarY) : null, this.railBorderYWidth = u(h.borderTopWidth) + u(h.borderBottomWidth), e(this.scrollbarYRail, { display: 'block' }), this.railYMarginHeight = u(h.marginTop) + u(h.marginBottom), e(this.scrollbarYRail, { display: '' }), this.railYHeight = null, this.railYRatio = null, this.reach = { x: n.scrollLeft <= 0 ? 'start' : n.scrollLeft >= this.contentWidth - this.containerWidth ? 'end' : null, y: n.scrollTop <= 0 ? 'start' : n.scrollTop >= this.contentHeight - this.containerHeight ? 'end' : null }, this.settings.handlers.forEach(function (t) { return H[t](l) }), this.event.bind(this.element, 'scroll', function () { return L(l) }), L(this) }; const E = { isInitialized: { configurable: !0 } }; return E.isInitialized.get = function () { return this.element.classList.contains(m.main) }, T.prototype.update = function () { this.isInitialized && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, e(this.scrollbarXRail, { display: 'block' }), e(this.scrollbarYRail, { display: 'block' }), this.railXMarginWidth = u(t(this.scrollbarXRail).marginLeft) + u(t(this.scrollbarXRail).marginRight), this.railYMarginHeight = u(t(this.scrollbarYRail).marginTop) + u(t(this.scrollbarYRail).marginBottom), e(this.scrollbarXRail, { display: 'none' }), e(this.scrollbarYRail, { display: 'none' }), L(this), e(this.scrollbarXRail, { display: '' }), e(this.scrollbarYRail, { display: '' })) }, T.prototype.destroy = function () { this.isInitialized && (this.event.unbindAll(), r(this.scrollbarX), r(this.scrollbarY), r(this.scrollbarXRail), r(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null) }, T.prototype.removePsClasses = function () { this.element.className = this.element.className.split(' ').filter(function (t) { return !t.match(/^ps([-_].+|)$/) }).join(' ') }, Object.defineProperties(T.prototype, E), T }))
